## Watch-only模式的共识节点

> **注意**: 本章节已更新至 Neo N3 版本。

正如可以在网络教程中验证的那样，NEO网络以完全分布式的方式运行。

![转发交易，直至达到共识节点（绿色）](https://cdn-images-1.medium.com/max/800/1*vKbm_Di8GgQep8SyKeAWNw.png)

绿色框代表共识节点。消息全部广播给相邻节点。具有特殊功能的节点可以设计为仅监控来自共识节点的P2P消息。

**Neo N3 共识节点配置：**
- 主网：21 个共识节点
- 测试网：7 个共识节点
- 私有链：可自定义（最少 4 个）

## dBFT 场景

为了举例说明一些可能的共识场景，考虑以下角色：

![dBFT共识节点角色](./cn_characters.jpg)

 -  **N1：** 张铮文，绝地大师 ;
 -  **N2：** 达鸿飞，智能经济的壁炉;
 -  **N3：** 林鹏涛，壁炉中的真相;
 -  **N4：** NEO 生态系统，用户、交易所和开发人员的所有项目和利益的总和;
 -  **N5：** City of Zion，世界各地的结合和合作;
 -  **N6：** NeoResearch Buterfly，探索、恢复和改造的能力;
 -  **N7：** 尤达大师，从过往的经验中学习。

通过使用这7个共识节点并结合他们的优点，我们会给出一些例子让读者了解dBFT机制的工作原理：

### 创世块 (Neo N3)

Neo N3 的创世块与 Neo Legacy 有显著不同：

- **无资产注册交易**：NEO 和 GAS 作为原生合约存在
- **原生合约部署**：所有原生合约在创世块初始化
- **初始 NEO 分配**：1 亿 NEO 分配给多签地址

```csharp
// Neo N3 创世块结构
public static Block Genesis => new()
{
    Header = new Header
    {
        Version = 0,
        PrevHash = UInt256.Zero,
        MerkleRoot = UInt256.Zero,
        Timestamp = (new DateTime(2021, 3, 1, 0, 0, 0, DateTimeKind.Utc)).ToTimestampMS(),
        Nonce = 2083236893,
        Index = 0,
        PrimaryIndex = 0,
        NextConsensus = GetConsensusAddress(StandbyValidators),
        Witness = new Witness { ... }
    },
    Transactions = Array.Empty<Transaction>()
};
```

### 情况 1 (正常运行)

- 我们处于高度`1`以及视图编号`0`, 议长节点是`N1`(考虑一个数学公式);
- 张铮文选择了由多签账户签名的第一组交易，并且发起了提案块`b_1_0`;
- 需要`2f+1`个节点对该提案达成一致。N2, N3, N4 and N5是首先响应希望处理这个区块的节点。包括N1,现在有5个节点 (正好是2f +1);
- N1, ..., N5可能会首先进入提交阶段。
- 处于提交阶段的节点会自动发送针对当前区块提案`b_1_0`的签名;
- 一旦节点收集到`2f+1`个签名，就会向网络广播一个有效地区块。即便是一个**watch-only模式的节点**也可能是第一个执行该任务的节点(突出显示了这个MAS环境可能的工作方式)。

### 情况 2 (议长故障)

- 现在我们处于高度`2`且视图编号为`0`, 议长节点是`N2`;
- 达鸿飞小睡了一会儿，在这几秒钟内无法与其他角色交流了;
- `2f+1`个节点同意应该`更改视图`。网络上没有任何进展，节点应该严格按照将`出块时间`左移1位来设置超时时间。如果是15秒，则超时时间是30秒。
- 议长节点更改为N3。
- N3节点只有在参与`视图更改`的情况下才会发起新的提案块, 否则, 它仍将等待`N2`的提案块。
- 考虑到N3得到了`2f+1`条`更改视图`消息, 它现在将发起新的提案块`b_2_1`;
- 从这里开始执行情况1下的正常流程。

### 情况 3 (提交之后发生故障)

- 现在我们处于高度`3`以及视图`0`, 议长节点是`N3`;
- N3发起了提案块`b_3_0`;
- 从`N3`, ..., `N7`开始的大多数节点都同意提案;
- 然而，在进入提交节点后，`N4`在广播其对区块`b_3_0`的签名前发生故障了;
- `N3`, `N5`, `N6` 以及`N7`，现在只有`2F`个节点，仍然还需要一个对`b_3_0`的签名。 可能的情况是: 1) `N4`从故障中恢复了; 2) `N1`以及`N2`可以看到它们丢失的消息; 3) `N1`和`N2`请求`更改视图`，但不会获得大多数`M` 的同意，其他节点将发送一条`Recovery`消息来响应它们, 在该消息中，它们将自动接收到所有已知的消息。一旦这3个节点中的任何一个收到此类消息，它们将对当前区块`b_3_0`进行操作。

需要注意的是，3个故障节点个数是`f+1`，这会阻止网络的运行。另一方面，应该注意的是，没有检测到真正的拜占庭行为，这只是延迟和连接的问题。从这个意义上来说，由于部分同步协议，消息有时会达到这些节点.

### 情况 4 (议长节点出现拜占庭)

- 现在我们处于高度`4`且视图编号为`0`, 议长节点是`N4`;
- `N4`是恶意节点，且试图向网络发送一个不同的区块;
- 每个节点设计为只接受每个`视图`下的单的提案。在大多数`M = 2f+1`个节点不能就同一个提案达成共识之前(通过`hash`汇总)，不会提交任何节点。
- 如果`M`个节点提交了而另外的`f = 2`个节点缓存了一个不同的提案块，它们将在某个时刻收到一条`Recover`消息, 这将允许它们匹配哈希值。如果哈希值不同，我们将有一个针对这个议长节点的反证，这肯定会使得NEO持有者将这个节点从验证人中删除。

## Neo N3 多签账户

Neo N3 的地址格式有重大变化：
- **地址前缀**：所有 N3 地址以 `N` 开头（版本号 0x35）
- **脚本格式**：使用新的验证脚本结构

### 多签脚本结构

```
[签名数量] [公钥1] [公钥2] ... [公钥n] [公钥数量] CHECKMULTISIG
```

示例（3/4 多签）：
```
13  // PUSH3 (需要3个签名)
21 02...6e  // 公钥1
21 02...62  // 公钥2  
21 02...c2  // 公钥3
21 03...99  // 公钥4
14  // PUSH4 (共4个公钥)
0b  // SYSCALL
41138def...  // System.Crypto.CheckMultisig
```

### 地址转换

```csharp
// Neo N3 地址转换
public static string ToAddress(this UInt160 scriptHash)
{
    byte addressVersion = 0x35;  // Neo N3: 'N' 开头
    Span<byte> data = stackalloc byte[21];
    data[0] = addressVersion;
    scriptHash.ToArray().CopyTo(data[1..]);
    return Base58.Base58CheckEncode(data);
}
```

[返回目录](README.md#目录)